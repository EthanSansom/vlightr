---
title: "vlightr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vlightr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

## Basic Usage

Highlighting makes it easy to identify the observations in a vector that
you care about.

```{r}
library(vlightr)
library(lubridate, warn.conflicts = FALSE)
set.seed(1)

# Which numbers are at or above the mean?
highlight(1:10, ~ .x >= mean(.x), ~ paste0("[", .x, "]"))

# Where are the vowels?
highlight(sample(letters, 6), ~ grepl("(a|e|i|o|u)", .x), toupper)

# Which interval is longer than one month?
highlight(
  interval(ymd("2021-01-01"), ymd("2021-01-01") + days(c(10, 33, 5))),
  ~ .x / dmonths(1) > 1,
  ~ paste("[ M+", .x, " ]")
)
```

Including the observations in a `tibble::tibble()`.

```{r}
work_from_home <- c(TRUE, FALSE, TRUE, FALSE, TRUE) 
salary <- c(1.5, 5, 12, 8, 4) * 10000

tibble::tibble(
  work_from_home = work_from_home,
  salary = highlight(salary, ~ .x == max(.x), ~ paste("[Max]", .x))
)
```

### Manipulating Highlighted Data

Highlighted vectors are designed to introduce as little friction as
possible, but they do require some legwork to use. Attempting to coerce
or convert a `vlightr_highlight` to another vector type will result in
an error.

```{r}
x <- 1:6
x_above_mean <- highlight(x, ~ .x >= mean(.x), ~ paste0("[", .x, "]"))

x
x_above_mean

try(x_above_mean[[5]] <- 100L)
```

Highlights are, however, compatible with other highlights. Where
possible, highlighted vectors have the same casting and coercion rules
as their underlying vector type.

```{r}
# <highlight<int>> and <highlight<int>> are compatible
x_above_mean[[5]] <- hl(100L)

# <highlight<int>> and <highlight<chr>> are not
try(x_above_mean[[5]] <- hl("100!"))
```

Arithmetic, comparison, and the math functions supported by
`vctrs::vec_math()` work out of the box.

```{r}
x_above_mean - hl(2.0)

pmin(x_above_mean, hl(4))

sum(x_above_mean)
```

Notice that the conditional formatting is persistent, so changing the
underlying data of a highlighted vector will also change how each
element is formatted.

### Highlight, Un-Highlight, Re-Highlight

By default, many functions won't know what to do with a highlighted vector, resulting in an error.

```{r}
try(as.logical(x_above_mean))
try(which.min(x_above_mean))
```

A highlight can be un-highlighted (converted back to it's original class) using
the `un_highlight()` function. This allows the highlighted vector to be used as
expected, at the expense of it's conditional formatting.

```{r}
as.logical(un_highlight(x_above_mean))
which.min(un_highlight(x_above_mean))
```

The `re_highlight()` function can be used to re-apply the conditional formatting removed by `un_highlight()`.

```{r}
re_highlight(as.logical(un_highlight(x_above_mean)), x_above_mean)
re_highlight(which.min(un_highlight(x_above_mean)), x_above_mean)
```

Together, `highlight()`, `un_highlight()`, and `re_highlight()` provide the core
functionality of `vlightr`.

1.  `highlight()` (synonym `hl()`) highlights a vector.
2.  `un_highlight()` (synonym `ul()`) removes a vector's highlighting
    (expose it's underlying data).
3.  `re_highlight()` (synonym `rl()`) applies the format of an existing
    highlighted vector to another vector.

These functions and their shorthand synonyms allow highlights to be used almost
as if they were normal vectors.

```{r}
# Emphasize `NA` values
indicators <- highlight(c(1L, 0L, NA, 1L), is.na, ~ paste("[", .x, "]"))

indicators
un_highlight(indicators)

# Convert to a logical vector
indicators |>
  un_highlight() |>
  as.logical() |>
  re_highlight(indicators)
```

The "highlight-pipe" `%hl>%` is a wrapper around the `magrittr::%>%` pipe which
does the un and re-highlighting automatically.

```{r}
indicators %hl>% as.logical()
```

`re_highlight(x, ...)` accepts any number of highlighted vectors `...` which are used to re-highlight the vector `x`. This is useful for restoring the conditional formatting of multiple highlights used within a single function.

```{r}
# Highlight phrases containing an exclamation
exclamations <- "(wow|neat|cool)"
exclaim <- highlight(
  c("wow that's great", "okay", "what a cool dude", "no"),
  ~ grepl(exclamations, .x),
  ~ paste0(.x, "!")
)
exclaim

# Highlight phrases containing a question
questions <- "(what|where|when)"
question <- highlight(
  c("news", "neat, when is that", "where is he", "thanks"),
  ~ grepl(questions, .x),
  ~ paste0(.x, "?")
)
question

# Un-Highlight, Do Something, Re-Highlight
paste(ul(exclaim), ul(question)) |> rl(exclaim, question)
```

If the first argument to `re_highlight()` is an already highlighted vector, then it's conditional formatting and that of the highlights supplied to `...` will be
combined. Only the data from `x` is used in the output vector.

```{r}
re_highlight(x = exclaim, question)
```

### Applying Multiple Formats

Multiple conditions and formatters can be specified by supplying lists
of functions or purrr-style lambdas.

```{r}
x_min_max <- highlight(
  x = x,
  conditions = list(
    ~ .x == min(.x), 
    ~ .x == max(.x)
  ),
  formatters = list(
    ~ paste0("(Min = ", .x, ")"), 
    ~ paste0("(Max = ", .x, ")")
  )
)
x_min_max
```

When two compatible highlights are combined, so are their `conditions`
and `formatters`.

```{r}
c(x_min_max[1:3], x_above_mean[2:4])
```

An error will occur if the combination of multiple highlights causes any
of `conditions` or `formatters` to fail.

```{r}
# A highlighted vector with a hidden error
int_hl <- highlight(
  c(1L, 2L, 3L), 
  conditions = ~ !is.integer(.x),
  formatters = \(x) stop("Integers only!")
)

# This runs fine
int_hl

# This does not
try(c(int_hl, hl(0.5)))
```

When defining more complex conditional formatting, `highlight_case()`
can make the relationship between the conditions and the corresponding
formats more clear.

```{r}
x_summary <- highlight_case(
  x = x,
  .x == min(.x) ~ \(x) paste0("(Min = ", x, ")"),
  .x == quantile(.x, 0.5) ~ \(x) paste0("(Mode = ", x, ")"),
  .x == max(.x) ~ \(x) paste0("(Max = ", x, ")"),
  .x > quantile(.x, 0.5) ~ \(x) paste("[ High", x, "]"),
  TRUE ~ \(x) paste("[ Low", x, "]")
)
x_summary
```

The syntax of `highlight_case()` is inspired by `dplyr::case_when()`. As
in `dplyr::case_when()`, each element of `x` is allowed to match exactly
one condition (the first condition that returns `TRUE` for that
element).

We can change this behavior using the `format_once` (`.format_once`)
argument, which is `FALSE` by default in `highlight()` and `TRUE` by
default in `highlight_case()`.

```{r}
highlight_case(
  x = x,
  .x == min(.x) ~ \(x) paste0("(Min = ", x, ")"),
  .x == max(.x) ~ \(x) paste0("(Max = ", x, ")"),
  .x > quantile(.x, 0.5) ~ \(x) paste("[ High", x, "]"),
  .format_once = FALSE
)
```

### Describing Conditional Formatting

If you're sharing highlighted vectors with others or just want to
remember what a highlight's format method is doing, the `description`
(`.description`) argument of `highlight()` (`highlight_case()`) is
especially useful.

When `describe_highlight()` is called on a highlighted vector, a
description of the conditional formatting is printed using highlight's
`description` attribute to provide additional context.

```{r}
# Re-define `x_summary` with a description
x_summary <- highlight_case(
  x = x,
  .x == min(.x) ~ \(x) paste0("(Min = ", x, ")"),
  .x == quantile(.x, 0.5) ~ \(x) paste0("(Mode = ", x, ")"),
  .x == max(.x) ~ \(x) paste0("(Max = ", x, ")"),
  .x > quantile(.x, 0.5) ~ \(x) paste("[ High", x, "]"),
  TRUE ~ \(x) paste("[ Low", x, "]"),
  .description = c(
    "Minimum Value(s)",
    "Mode Value(s)",
    "Maximum Value(s)",
    "Value(s) above the Mode",
    "Values(s) below the Mode"
  )
)

# Describe the conditional formatting
describe_highlight(x_summary)
```

Notice that there is no example of an element formatted with the
`"2. Mode Value(s)"` formatter. This is because no element of
`x_summary` is exactly equal to it's mode. This can be verified as
follows:

```{r}
# Get the `conditions` functions and `description` of `x_summary`
conditions <- attr(x_summary, which = "conditions")
description <- attr(x_summary, which = "description")

# Get the "element is the mode" condition
mode_condition <- conditions[[which(description == "Mode Value(s)")]]

# Test whether any element of `x_summary` is the mode
mode_condition(un_highlight(x_summary))
```

Instead of re-defining a highlighted vector to change it's attributes
(i.e. the arguments to `highlight()`), the function `update_highlight()`
can be used to revise an existing highlight. It takes the same arguments
as `highlight()` and returns a highlighted vector with updated
attributes.

```{r}
x_summary <- update_highlight(
  x_summary,
  description = c("Min.", "P50", "Max", ">P50", "<P50")
)
describe_highlight(x_summary)
```

In cases where `format_once = TRUE`, there will be at most one
conditional format applied to each element of a highlighted vector. If
`format_once = FALSE`, however, an element can be formatted by several
`formatters`.

In this case, `describe_highlight()` will show an example of each
realized combination of conditional formats.

```{r}
x_summary <- update_highlight(x_summary, format_once = FALSE)
describe_highlight(x_summary)
```

Note that every element is formatted using the `"<P50"` formatter. This
is because when `x_summary` was originally defined using
`highlight_case()`, the final condition was a function which always
returns `TRUE`.

```{r}
last_condition <- attr(x_summary, "conditions")[[5]]
last_condition()
```

## Highlighters

`as_highlighter()` converts a conditionally formatted vector to a
function which applies the same conditional formatting to other vectors.

```{r}
summary_highlighter <- as_highlighter(x_summary)
summary_highlighter(1:5)
```

Highlighter functions accept the same arguments as `highlight()`, so
additional highlights can be applied on top of existing ones.

```{r}
summary_highlighter(
  x = 1:5, 
  conditions = ~ .x > 0, 
  formatters = ~ paste0("+", .x), 
  format_once = FALSE,
  precedence = 0
)
```

Notice the use of the `precedence` argument. This controls the order in
which conditional formats are applied. By default `formatters` are
applied in the order in which they were supplied.

```{r}
# Check whether `x` is odd and then whether `x` is positive
highlight(
  x = -2:1, 
  conditions = list(~ .x %% 2 != 0, ~ .x > 0),
  formatters = list(~ paste(.x, "is odd"), ~ paste(.x, "and positive"))
)

# Reverse the `precedence`
highlight(
  x = -2:1, 
  conditions = list(~ .x %% 2 != 0, ~ .x > 0),
  formatters = list(~ paste(.x, "is odd"), ~ paste(.x, "and positive")),
  precedence = 2:1
)
```

A highlighter can be defined from scratch using `highlighter()` or
`highlighter_case()`. These functions take the same arguments as
`highlight()` and `highlight_case()` respectively, except for the first
argument `x`.

```{r}
secret <- highlighter(
  conditions = ~ grepl("^<.*>$", .x), 
  formatters = ~ strrep("x", nchar(.x) - 2L)
)
secret(c("This", "<is>", "a", "<secret>", "<.>"))

dollars <- highlighter_case(
  is.na(.x) ~ \(x) "NA",
  .x < 0 ~ \(x) paste0("-$", round(abs(as.numeric(x)), digits = 2)),
  .x >= 0 ~ \(x) paste0("$", round(abs(as.numeric(x)), digits = 2))
)
dollars(c(-10, 0.12, 130.0234, NA))

no_nas <- highlighter_case(is.na(.x) ~ \(x) "NO PROBLEM")
no_nas(c(TRUE, FALSE, NA))
```

## Styling

ANSI escape sequences, such as those used to color text in the `cli`
package, are also supported. The code below colors the formatted `NA`
values red.

```{r}
highlight(c(1, 0, NA), is.na, cli::col_red)
```

Unfortunately, the R Markdown code blocks used in this vignette do not
display printed output in color, so you'll have to take my word for it.
Please see the README for some full-color examples.

`vlightr` provides some convenience functions for selecting `cli`
functions to use as formatters.

-   `color()` and `colour()` return a `cli::col_*` function which colors
    text

-   `bg()` and `background()` return a `cli::bg_*` function which colors
    the text's background

-   `style()` returns a `cli::style_*` function which can bold,
    underline, or italicize text among other things

See `cli` ANSI colored text for more information. (TODO Add link).

For example, the same NA highlight as above can be achieved like so:

```{r, eval = FALSE}
highlight(c(1, 0, NA), is.na, colour("red"))
```

## Generic Highlighting

-   some examples from lubridate and ivs
-   function `is_highlightable`
-   what CAN'T you highlight -\> data frames and bare lists
-   demonstrate the use of the `init_formatter` to add better default
    formatting, with a lubridate ymd_hms interval (interval(now(),
    now()) is super long, truncate)

```{r}
long_interval <- interval(now(), now(), tzone = "UTC")

format_interval <- function(x) {
  starts <- as.Date(int_start(x))
  ends <- as.Date(int_end(x))
  tzone <- attr(x, "tzone")
  
  out <- paste(starts, "-", ends, tzone)
  out[is.na(x)] <- NA
  out
}

highlight_interval <- highlighter(init_formatter = format_interval)
highlight_interval(long_interval)
```

Similarly, the `last_formatter` is applied after all of the conditional
formatting has been added. This is useful for limiting the text width of
a formatted highlight.

```{r}
truncate_formatter <- function(x, char_limit = 40) {
  # Check which strings in `x` exceed the `char_limit` 
  x_char <- nchar(x)
  above_limit <- x_char > char_limit
  if (!any(above_limit)) {
    return(x)
  }
  
  # Split strings above the `char_limit` into a prefix and suffix, 
  # leaving room to insert a "..." in between.
  substr_size <- floor(char_limit / 2)
  suffix_start <- x_char[above_limit] - substr_size + 2
  x_prefix <- substr(x[above_limit], 1, substr_size - 1)
  x_suffix <- substr(x[above_limit], suffix_start, x_char[above_limit])
  
  # Truncate the too-long strings and insert a "..." in the middle
  x[above_limit] <- paste0(x_prefix, "...", x_suffix)
  x
}

# Test the formatter
truncate_formatter(c("this", "is", "a", "huuuuuuuuuge", "character"), 7)

# In a highlighter
highlight_interval <- highlighter(
  init_formatter = format_interval,
  last_formatter = truncate_formatter
)
highlight_interval(
  long_interval,
  conditions = ~ int_start(.x) > as.Date("2000-01-01"),
  formatters = ~ paste(.x, "(is in the 21st Century)")
)
```

## Under the Hood

This section is meant to provide some intuition into how
`vlighter_highlight` vectors are formatted.

Consider the vector `x_hl` defined below. We'll just assume that `x` is
some highlight-able vector and `conditions`, `formatters`, `precedence`,
`init_formatter`, and `last_formatter` are all valid arguments.

```{r, eval = FALSE}
x_hl <- highlight(
 x = x,
 conditions = conditions,
 formatters = formatters,
 precedence = precedence,
 init_formatter = init_formatter,
 last_formatter = last_formatter
)
```

When `format(x_hl)` is called (e.g. within `print()`) the following
psuedo-code is executed.

```{r, eval = FALSE}
# Apply an initial format to `x`, converting `x` into a character vector.
formatted <- init_formatter(x)

# Apply each format in `formatters` to the elements of `x` which meet a 
# condition. Do so in the order specified by `precedence`.
format_order <- order(precedence)
for (i in format_order) {
  condition <- conditions[[i]]
  formatter <- formatters[[i]]
  condition_is_met <- condition(x)
  formatted[condition_is_met] <- formatter(formatted[condition_is_met])
}

# Apply the last format before returning
last_formatter(formatted)
```

The `init_formatter` is the only formatter function which has access to
the underlying vector data in `x`. As such, all conditional formatting
performed by the `conditions` or `formatters` could be performed by the
`init_formatter` alone.
