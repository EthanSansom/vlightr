---
title: Conditionally format generic vectors
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vlightr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

vlightr makes it easy to identify the observations in a vector that you care about.

```{r}
library(vlightr)

# Which numbers are above the mean?
highlight(1:10, ~ .x > mean(.x), ~ paste0("[", .x, "]"))
```

Including the observations in a `tibble::tibble()`.

```{r, collapse=TRUE}
work_from_home <- c(TRUE, FALSE, TRUE, FALSE, TRUE) 
salary <- c(1.5, 5, 12, 8, 4) * 10000

tibble::tibble(
  work_from_home = work_from_home,
  salary = highlight(salary, ~ .x == max(.x), ~ paste("[Max]", .x))
)
```

### Conditional Formatting

For it's basic functionality, the `highlight()` function requires 3 arguments: 
`x`, `conditions`, and `formatters`.

```{r, eval = FALSE}
above_mean <- highlight(
  # A generic vector to conditionally format
  x = 1:10,
  # Condition(s), determine which elements of `x` are formatted
  conditions = ~ .x > mean(.x),
  # Formatter(s), specify how chosen elements of `x` are formatted
  formatters = ~ paste0("[", .x, "]")
)
```

Multiple `conditions` and `formatters` can be specified by supplying
lists of functions or purrr-style lambdas. Elements of `x` for which
`conditions[[i]](x)` returns `TRUE` are formatted using
`formatters[[i]]`.

```{r}
even_or_negative <- highlight(
  x = -4:3,
  conditions = list(~ .x %% 2 == 0, \(x) x < 0),
  formatters = list(\(x) paste0("[", x, "]"), ~ paste0("(", .x, ")"))
)
print(even_or_negative)
```

By default, `formatters` are applied in the order that they were supplied. You 
can change the order of application by supplying a `precedence`.

```{r}
highlight(
  x = even_or_negative,
  conditions = list(~ .x %% 2 == 0, \(x) x < 0),
  formatters = list(\(x) paste0("[", x, "]"), ~ paste0("(", .x, ")")),
  precedence = c(2, 1)
)
```

A highlighted vector's conditional formatting can also be updated using 
`update_highlight()`, which takes the same arguments as `highlight()`.

```{r}
even_or_negative <- update_highlight(even_or_negative, precedence = c(2, 1))
print(even_or_negative)
```

Elements of `even_or_negative` which meet multiple conditions (i.e. are even
and negative) are formatted multiple times (e.g. `"[(-4)]"`, `"[(-2)]"`). To 
format elements according to the first condition met, set `format_once = TRUE`.

```{r}
update_highlight(even_or_negative, format_once = TRUE)
```

`describe_highlight()` is useful to understand how a highlight is formatted.

```{r}
describe_highlight(even_or_negative)
```

The `describe_highlight()` function uses the `description` attribute of a highlighted
vector to provide additional context.

```{r}
even_or_negative <- update_highlight(
  even_or_negative, 
  description = c("Even", "Negative")
)
describe_highlight(even_or_negative)
```

### Manipulating Highlighted Data

Highlighted vectors (class `vlightr_highlight`) are designed to introduce as 
little friction as possible, but they do require some legwork to use. Attempting 
to coerce or convert a `vlightr_highlight` to another vector type will result in
an error.

```{r}
mean_or_above <- highlight(1:6, ~ .x >= mean(.x), ~ paste0("[", .x, "]"))
try(mean_or_above[[5]] <- 100L)
```

Highlights are, however, compatible with other highlights. Where
possible, highlighted vectors have the same casting and coercion rules
as their underlying vector type.

```{r}
# <highlight<int>> and <highlight<int>> are compatible
mean_or_above[[5]] <- hl(100L)

# <highlight<int>> and <highlight<chr>> are not
try(mean_or_above[[5]] <- hl("100!"))
```

Arithmetic, comparison, and the math functions supported by
`vctrs::vec_math()` work out of the box.

```{r}
# Arithmetic
mean_or_above - hl(2.0)
# Comparison
pmin(mean_or_above, hl(4))
# Math
sum(mean_or_above)
```

Notice that the conditional formatting is persistent, so changing the
underlying data of a highlighted vector will also change how each
element is formatted.

### Highlight, Un-Highlight, Re-Highlight

By default, many functions won't know what to do with a highlighted
vector, resulting in an error.

```{r}
try(as.logical(mean_or_above))
try(which.min(mean_or_above))
```

A highlight can be un-highlighted (converted back to it's original
class) using the `un_highlight()` function. This allows the highlighted
vector to be used as expected, at the expense of it's conditional
formatting.

```{r}
as.logical(un_highlight(mean_or_above))
which.min(un_highlight(mean_or_above))
```

The `re_highlight()` function can be used to re-apply the conditional
formatting removed by `un_highlight()`.

```{r}
re_highlight(as.logical(un_highlight(mean_or_above)), mean_or_above)
re_highlight(which.min(un_highlight(mean_or_above)), mean_or_above)
```

Together, `highlight()`, `un_highlight()`, and `re_highlight()` provide
the core functionality of `vlightr`.

1.  `highlight()` (synonym `hl()`) highlights a vector.
2.  `un_highlight()` (synonym `ul()`) removes a vector's highlighting
    (expose it's underlying data).
3.  `re_highlight()` (synonym `rl()`) applies the format of an existing
    highlighted vector to another vector.

These functions and their shorthand synonyms allow highlights to be used
almost as if they were normal vectors.

```{r}
# Emphasize `NA` values
indicators <- highlight(c(1L, 0L, NA, 1L), is.na, ~ paste("[", .x, "]"))
indicators
# Convert to a logical vector
indicators |>
  un_highlight() |>
  as.logical() |>
  re_highlight(indicators)
```

The "highlight-pipe" `%hl>%` is a wrapper around the
[magrittr](https://magrittr.tidyverse.org/reference/pipe.html) `%>%`
pipe which un-highlights the left-hand-side input and re-highlights the
right-hand-side output.

```{r}
indicators %hl>% as.logical()
```

`re_highlight(x, ...)` accepts any number of highlighted vectors `...`
which are used to re-highlight the vector `x`. This is useful for
restoring the conditional formatting of multiple highlights used within
a single function.

```{r}
# Highlight phrases containing an exclamation
exclamations <- "(wow|neat|cool)"
exclaim <- highlight(
  c("wow that's great", "okay", "what a cool dude", "no"),
  ~ grepl(exclamations, .x),
  ~ paste0(.x, "!")
)
exclaim
# Highlight phrases containing a question
questions <- "(what|where|when)"
question <- highlight(
  c("news", "neat, when is that", "where is he", "thanks"),
  ~ grepl(questions, .x),
  ~ paste0(.x, "?")
)
question
# Un-Highlight, Do Something, Re-Highlight
paste(ul(exclaim), ul(question)) |> rl(exclaim, question)
```

If the `x` argument to `re_highlight()` is a highlighted vector, then
it's conditional formatting and that of the highlights supplied to `...`
will be combined. Only the data from `x` is used in the output vector.

```{r}
re_highlight(x = exclaim, question)
```

### Applying Multiple Formats

Multiple conditions and formatters can be specified by supplying lists
of functions or purrr-style lambdas.

```{r}
min_max <- highlight(
  x = 1:5,
  conditions = list(
    ~ .x == min(.x), 
    ~ .x == max(.x)
  ),
  formatters = list(
    ~ paste0("(Min = ", .x, ")"), 
    ~ paste0("(Max = ", .x, ")")
  )
)
print(min_max)
```

When two compatible highlights are combined, so are their `conditions`
and `formatters`.

```{r, collapse=TRUE}
c(min_max[1:3], mean_or_above[2:4])
```

An error will occur if the combination of multiple highlights causes any
of `conditions` or `formatters` to fail.

```{r, collapse=TRUE}
# A highlighted vector with a hidden error
int_hl <- highlight(
  c(1L, 2L, 3L), 
  conditions = ~ !is.integer(.x),
  formatters = \(x) stop("Integers only!")
)

# This runs fine
int_hl
# This does not
try(c(int_hl, hl(0.5)))
```

When defining more complex conditional formatting, `highlight_case()` (inspired
by `dplyr::case_when()`) can make the relationship between a conditions it's 
corresponding format more clear.

```{r, collapse=TRUE}
summary_hl <- highlight_case(
  x = 1:7,
  .x == min(.x) ~ \(x) paste0("(Min = ", x, ")"),
  .x == quantile(.x, 0.5) ~ \(x) paste0("(Mode = ", x, ")"),
  .x == max(.x) ~ \(x) paste0("(Max = ", x, ")"),
  .x > quantile(.x, 0.5) ~ \(x) paste("[ High", x, "]"),
  TRUE ~ \(x) paste("[ Low", x, "]")
)
summary_hl
```

Unlike in `highlight()`, the `.format_once` argument of `highlight_case()` is 
`TRUE` by default. As in `dplyr::case_when()`, this means that each element of 
`x` is allowed to match exactly one condition (the first condition matched).

### Highlighters

`as_highlighter()` converts a conditionally formatted vector to a
function which applies the same conditional formatting to other vectors.

```{r, collapse=TRUE}
summary_highlighter <- as_highlighter(summary_hl)
summary_highlighter(1:5)
```

Highlighter functions accept the same arguments as `highlight()`, so
additional highlights can be applied on top of existing ones.

```{r, collapse=TRUE}
summary_highlighter(
  x = 1:5, 
  conditions = ~ .x > 0, 
  formatters = ~ paste0("+", .x),
  precedence = 0
)
```

A highlighter can be defined from scratch using `highlighter()` or
`highlighter_case()`. These functions take the same arguments as
`highlight()` and `highlight_case()` respectively, excluding the first
argument `x`.

```{r}
secret <- highlighter(
  conditions = ~ grepl("^<.*>$", .x), 
  formatters = ~ strrep("x", nchar(.x) - 2L)
)
secret(c("This", "<is>", "a", "<secret>", "<.>"))
dollars <- highlighter_case(
  is.na(.x) ~ "NA",
  .x > 0 ~ paste0("-$", .x),
  TRUE ~ paste0("$", .x),
  .init_formatter = \(x) sprintf("%.2f", abs(x))
)
dollars(c(-10, 0.12, 130.0234, NA))
no_nas <- highlighter_case(is.na(.x) ~ "NO PROBLEM")
no_nas(c(TRUE, FALSE, NA))
```

### Styling

ANSI escape sequences, such as those used to color text in the `cli`
package, are also supported. The code below colors the formatted `NA`
values red.

```{r, collapse=TRUE}
highlight(c(1, 0, NA), is.na, cli::col_red)
```

vlightr provides some convenience functions for selecting `cli` functions to use 
as formatters.

-   `color()` and `colour()` return a `cli::col_*` function which colors
    text

-   `bg()` and `background()` return a `cli::bg_*` function which colors
    the text's background

-   `style()` returns a `cli::style_*` function which can bold,
    underline, or italicize text among other things

See `cli::style_bold()` and friends for details.

For example, the same `NA` highlight as above can be achieved like so:

```{r}
highlight(c(1, 0, NA), is.na, colour("red"))
```

### Generic Highlighting

-   some examples from lubridate and ivs
-   function `is_highlightable`
-   what CAN'T you highlight -\> data frames and bare lists
-   demonstrate the use of the `init_formatter` to add better default
    formatting, with a lubridate ymd_hms interval (interval(now(),
    now()) is super long, truncate)

```{r}
library(lubridate, warn.conflicts = FALSE)

long_interval <- interval(now(), now(), tzone = "UTC")

format_interval <- function(x) {
  starts <- as.Date(int_start(x))
  ends <- as.Date(int_end(x))
  tzone <- attr(x, "tzone")
  
  out <- paste(starts, "-", ends, tzone)
  out[is.na(x)] <- NA
  out
}

highlight_interval <- highlighter(init_formatter = format_interval)
highlight_interval(long_interval)
```

Similarly, the `last_formatter` is applied after all of the conditional
formatting has been added. This is useful for limiting the text width of
a formatted highlight.

```{r}
truncate_formatter <- function(x, char_limit = 40) {
  # Check which strings in `x` exceed the `char_limit` 
  x_char <- nchar(x)
  above_limit <- x_char > char_limit
  if (!any(above_limit)) {
    return(x)
  }
  
  # Split strings above the `char_limit` into a prefix and suffix, 
  # leaving room to insert a "..." in between.
  substr_size <- floor(char_limit / 2)
  suffix_start <- x_char[above_limit] - substr_size + 2
  x_prefix <- substr(x[above_limit], 1, substr_size - 1)
  x_suffix <- substr(x[above_limit], suffix_start, x_char[above_limit])
  
  # Truncate the too-long strings and insert a "..." in the middle
  x[above_limit] <- paste0(x_prefix, "...", x_suffix)
  x
}

# Test the formatter
truncate_formatter(c("this", "is", "a", "huuuuuuuuuge", "character"), 7)

# In a highlighter
highlight_interval <- highlighter(
  init_formatter = format_interval,
  last_formatter = truncate_formatter
)
highlight_interval(
  long_interval,
  conditions = ~ int_start(.x) > as.Date("2000-01-01"),
  formatters = ~ paste(.x, "(is in the 21st Century)")
)
```

### Under the Hood

This section is meant to provide some intuition into how
`vlighter_highlight` vectors are formatted.

Consider the vector `x_hl` defined below. We'll just assume that `x` is
some highlight-able vector and `conditions`, `formatters`, `precedence`,
`init_formatter`, and `last_formatter` are all valid arguments.

```{r, eval = FALSE}
x_hl <- highlight(
 x = x,
 conditions = conditions,
 formatters = formatters,
 precedence = precedence,
 init_formatter = init_formatter,
 last_formatter = last_formatter
)
```

When `format(x_hl)` is called (e.g. within `print()`) the following
psuedo-code is executed.

```{r, eval = FALSE}
# Apply an initial format to `x`, converting `x` into a character vector.
formatted <- init_formatter(x)

# Apply each format in `formatters` to the elements of `x` which meet a 
# condition. Do so in the order specified by `precedence`.
format_order <- order(precedence)
for (i in format_order) {
  condition <- conditions[[i]]
  formatter <- formatters[[i]]
  condition_is_met <- condition(x)
  formatted[condition_is_met] <- formatter(formatted[condition_is_met])
}

# Apply the last format before returning
last_formatter(formatted)
```

The `init_formatter` is the only formatter function which has access to
the underlying vector data in `x`. As such, all conditional formatting
performed by the `conditions` or `formatters` could be performed by the
`init_formatter` alone.
