% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/highlight.R
\name{highlight}
\alias{highlight}
\alias{hl}
\alias{highlight_case}
\alias{hl_case}
\title{Conditionally format a vector}
\usage{
highlight(
  x = logical(),
  conditions = list(),
  formatters = list(),
  description = NULL,
  precedence = NULL,
  format_once = FALSE,
  init_formatter = NULL,
  last_formatter = NULL
)

hl(
  x = logical(),
  conditions = list(),
  formatters = list(),
  description = NULL,
  precedence = NULL,
  format_once = FALSE,
  init_formatter = NULL,
  last_formatter = NULL
)

highlight_case(
  x,
  ...,
  .description = NULL,
  .precedence = NULL,
  .format_once = TRUE,
  .init_formatter = NULL,
  .last_formatter = NULL
)

hl_case(
  x,
  ...,
  .description = NULL,
  .precedence = NULL,
  .format_once = TRUE,
  .init_formatter = NULL,
  .last_formatter = NULL
)
}
\arguments{
\item{x}{\verb{[vector]}

A vector to highlight. Conceptually, a vector is a collection of objects of
size 1.

\code{x} is considered a vector if:
\itemize{
\item \code{x} is not a \link{data.frame}
\item \code{x} is not a bare \link{list}
\item \code{x} is otherwise a vector, as defined by \code{\link[vctrs:vector-checks]{vctrs::obj_is_vector()}}
}

Atomic vector types \code{"logical"}, \code{"integer"}, \code{"double"}, \code{"complex"},
\code{"character"}, and \code{"raw"} meet these criteria. As do many common vector
classes such as \code{POSIXct}, \code{lubridate::interval}, or \code{ivs::iv}.}

\item{conditions}{\verb{[function / list]}

Functions that indicate which elements of \code{x} to format. Can be a:
\itemize{
\item Function, e.g. \code{is.na}
\item A purrr-style lambda, e.g. \code{~ nchar(.x) > 0}, \code{~ TRUE}
\item A list of functions or lambdas, e.g. \code{list(~ .x < mean(.x), is.infinite)}
}

Each function in \code{conditions} will receive \code{x} as it's input and must return
a logical vector the same length as \code{x} or of length 1 (in which case the
result will be recycled to the length of \code{x}).

Elements of \code{x} for which \code{conditions[[i]](x)} is \code{TRUE} are formatted using
the formatter function \code{formatters[[i]]}. If both \code{conditions} and \code{formatters}
are supplied, then they must be the same length.}

\item{formatters}{\verb{[function / list]}

Character manipulation functions used to format \code{x}. Can be a:
\itemize{
\item Function, e.g. \link[cli:ansi-styles]{cli::style_bold}
\item A purrr-style lambda, e.g. \code{~ paste0(.x, "!")}, \code{~ "Hi"}
\item A list of functions or lambdas, e.g. \code{list(~ cli::col_red, toupper)}
}

When called, a function in \code{formatters} will receive a single character vector
(of variable length) as it's only argument. A formatter must return a character
vector the same length as it's input or of length 1 (in which case the result
is recycled to the length of the input character).

ANSI string vectors (class \code{cli_ansi_string}) are also supported (see
\link[cli:ansi-styles]{cli::ansi-styles} for details).

When \code{formatters} is not supplied a default set of formatters are provided.
By default, the formatters are a list of \code{cli::bg_br_yellow}, \code{cli::bg_br_green},
\code{cli::bg_br_red}, \code{cli::bg_br_cyan}, \code{cli::bg_br_magenta}, and \code{cli::bg_br_blue},
repeated to the length of \code{conditions}.

If the option \code{vlightr.colorful_default_formatters} is set via \code{options()} to
anything other than \code{TRUE}, then the default \code{formatters} will append numbered
annotations \code{"[1]"}, \code{"[2]"}, etc. to conditionally formatted elements, instead
of using \verb{cli::bg_*} functions.}

\item{description, .description}{\verb{[character / NULL]}

An optional description of the conditional format applied by each function
in \code{formatters}. This information is used by \code{\link[=describe_highlight]{describe_highlight()}}.

If supplied, \code{description} must be the same length as \code{conditions}.}

\item{precedence, .precedence}{\verb{[numeric / NULL]}

A numeric vector indicating the order in which to apply the \code{formatters}. The
formatter with the lowest corresponding \code{precedence} value is evaluated first
during formatting. By default \code{formatters} are applied in the order in which
they were supplied.

If supplied, \code{precedence} must be the same length as \code{conditions}.}

\item{format_once, .format_once}{\verb{[logical(1)]}

A \code{TRUE} or \code{FALSE} value. Indicates whether an element of \code{x} which meets
multiple \code{conditions} should be formatted only once (using the formatter
corresponding to the first condition met) or formatted multiple times (using
all of the corresponding \code{formatters}).

\code{format_once} is \code{FALSE} by default in \code{highlight()} and \code{TRUE} by default in
\code{highlight_case()}.}

\item{init_formatter, .init_formatter}{\verb{[function / NULL]}

The first function used to format \code{x}. When the highlighted vector is formatted,
\code{init_formatter(x)} is called prior to conditionally formatting \code{x} (i.e. before
any of the \code{formatters} are called.

If \code{NULL}, then \code{format(x)} is called instead.}

\item{last_formatter, .last_formatter}{\verb{[function / NULL]}

The last function called to format \code{x}. The \code{last_formatter} is applied
after \code{x} has been conditionally formatted (i.e. after the \code{init_formatter}
and \code{formatters} functions have been called).

\code{last_formatter} will receive a character vector the same length as
\code{x} as it's only argument. If \code{NULL}, the conditionally formatted \code{x}
is returned as is after formatting.}

\item{...}{\verb{[formula]}

For \code{highlighter_case()}, a two sided formula with a condition on the
left-hand-side and a formatter on the right-hand-side.

This argument replaces the \code{formatters} and \code{conditions} arguments of
\code{highlight()}. The i-th dot supplied is roughly equivalent to
\code{conditions[[i]] ~ formatters[[i]]}.

The left-hand-side and right-hand-side of the formula may be a:
\itemize{
\item Function, e.g. \code{rlang::is_string}, \code{toupper}
\item A purrr-style lambda expression, e.g. \code{TRUE}, \code{paste(.x, "?")}
}

The left-hand-side and right-hand-side of the formula may not be a call to a
generator function (i.e. a function which returns another function). Examples
include \code{\link[=wrap]{wrap()}}, \code{\link[=color]{color()}}, and \code{\link[=bg]{bg()}}. To use such a function, call it
within a lambda expression instead, e.g. \code{color("blue")(.x)}.

Examples of arguments to \code{...} include:
\itemize{
\item Colour \code{NA} values red: \code{is.na ~ cli::col_red}
\item Add an exclamation mark: \code{toupper(.x) == .x ~ paste0(.x, "!")}
\item Replace 1's with 2's: \code{.x == 1 ~ "2"}
\item Colour the background yellow by default: \code{TRUE ~ bg("yellow")(.x)}
}}
}
\value{
A highlighted vector (class \code{vlightr_highlight}) containing the same data as
\code{x}.
}
\description{
\code{highlight()} creates a vector with a conditional \code{\link[=format]{format()}}
method. The highlighted vector \code{highlight(1:5)} can (with limited legwork) be
treated exactly the same as the integer vector \code{1:5}, but has a different
\code{format()} and \code{print()} method.

\code{highlight_case()} provides an alternative \code{\link[dplyr:case_when]{dplyr::case_when()}} style syntax
to \code{highlight()}. Arguments (other than \code{x}) to \code{highlight_case()} are prefixed
with a dot.

\code{hl()} and \code{highlight()} are synonyms, as are \code{hl_case()} and
\code{highlight_case()}.
}
\details{
The \code{highlighter_case()} formula syntax is not compatible with
\code{dplyr::across()} in-lined formulas. In particular, in the call below:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ across(
   y,
   ~highlight_case(.x, is.na(.x) ~ paste0('<', .x, '>'))
 )
}\if{html}{\out{</div>}}

The expression \code{is.na(.x) ~ paste0('<', .x, '>')} will be replaced with
\code{is.na(y) ~ paste0('<', y, '>')} by \code{across()}. Because vlightr expects
the case formula to be in terms of \code{.x} (and not \code{y}), this creates an invalid
condition and formatter function within the highlighted vector (column) \code{y}.

To avoid this behavior, either use functions (e.g. \verb{\\(x) is.na(x)}) within
the \code{highlight_case()} formula, or use a lambda function instead of a formula
within \code{across()}, like so:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ across(
   y,
   \\(col) highlight_case(col, is.na(.x) ~ paste0('<', .x, '>'))
 )
}\if{html}{\out{</div>}}

Note that this is not an issue within other \code{dplyr} verbs, such as
\code{dplyr::summarize()} or \code{dplyr::mutate()}. The following will work as
expected:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ mutate(
   y = highlight_case(y, is.na(.x) ~ paste0('<', .x, '>'))
 )
}\if{html}{\out{</div>}}
}
\examples{
# Color NA values red
x <- c(1, 0, NA, 1, 0)
x_hl <- highlight(x, is.na, color("red"))
print(x)
print(x_hl)
describe_highlight(x_hl)

# Label indicators 1 and 0 by adding highlights to `x_hl`
x_hl <- highlight(
  x_hl,
  conditions = list(is.na, ~ .x == 1, ~ .x == 0),
  formatters = list(color("red"), ~ paste(.x, "[Yes]"), ~ paste(.x, "[No]"))
)
print(x_hl)
describe_highlight(x_hl)

# Using `dplyr::case_when` style syntax.
x_hl_case <- highlight_case(
  x,
  is.na(.x) ~ cli::col_red,
  .x == 1 ~ paste(.x, "[Yes]"),
  .x == 0 ~ paste(.x, "[No]"),
  .description = c(
    "Colored Red if NA",
    "Labelled Yes if 1",
    "Labelled No if 0"
  )
)
print(x_hl_case)
describe_highlight(x_hl_case)

# Make a `highlighter` to apply the format of `x_hl_case`
indicator_highlighter <- as_highlighter(x_hl_case)
indicator_highlighter(c(1, 0, 1, NA, 0, 0))

# Apply multiple formats to the same element
x_multi <- highlight(
  x = 1:6,
  conditions = list(~ .x \%\% 2 == 0, ~ .x > 3),
  formatters = list(wrap("<", ">"), wrap("[", "]"))
)
print(x_multi)

# Apply a single format to each element with `format_once`
update_highlight(x_multi, format_once = TRUE)

# Use an `init_formatter` to pre-format a highlight
dollar <- highlight_case(
  x = c(10, -1.45, 1.046, -8, NA),
  is.na(.x) ~ \(x) "NA",
  .x > 0 ~ \(x) paste0("-$", x),
  TRUE ~ \(x) paste0("$", x),
  .init_formatter = \(x) sprintf("\%.2f", abs(x))
)
print(dollar)

# Default `formatters`
highlight(1:6, conditions = ~ .x \%\% 2 == 0)
highlight(-2:2, conditions = list(~ .x > 0, ~ .x < 0))

# Change the default `formatters` using `options()`
opts <- options(vlightr.colorful_default_formatters = FALSE)
highlight(-2:2, conditions = list(~ .x > 0, ~ .x < 0))
options(opts)
}
\seealso{
\code{\link[=un_highlight]{un_highlight()}} for converting a vector \code{highlight(x)} back to \code{x}.

\code{\link[=update_highlight]{update_highlight()}} for changing any of \code{conditions}, \code{formatters},
\code{descripton}, \code{precedence}, \code{format_once}, \code{init_formatter}, or
\code{last_formater} in an already highlighted vector.

\code{\link[=as_highlighter]{as_highlighter()}} to generate a \code{\link[=highlighter]{highlighter()}} function which applies the
same conditional formatting as the input highlighted vector.
}
