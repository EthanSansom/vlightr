% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/highlight.R
\name{highlight}
\alias{highlight}
\alias{hl}
\alias{highlight_mult}
\alias{hl_mult}
\alias{highlight_case}
\alias{hl_case}
\title{Conditionally format a vector}
\usage{
highlight(
  .x = logical(),
  .t = getOption("vlightr.default_test"),
  .f = getOption("vlightr.default_formatter")
)

hl(
  .x = logical(),
  .t = getOption("vlightr.default_test"),
  .f = getOption("vlightr.default_formatter")
)

highlight_mult(.x, ...)

hl_mult(.x, ...)

highlight_case(.x, ...)

hl_case(.x, ...)
}
\arguments{
\item{.x}{\verb{[vector]}

A vector to highlight. Conceptually, a vector is a collection of objects of
size 1.

\code{.x} is considered a vector if:
\itemize{
\item \code{.x} is not a \link{data.frame}
\item \code{.x} is not a bare \link{list}
\item \code{.x} is otherwise a vector, as defined by \code{\link[vctrs:vector-checks]{vctrs::obj_is_vector()}}
}

Atomic vector types \code{"logical"}, \code{"integer"}, \code{"double"}, \code{"complex"},
\code{"character"}, and \code{"raw"} meet these criteria. As do many common vector
classes such as \code{POSIXct}, \code{lubridate::interval}, or \code{ivs::iv}.

By default \code{.x} is an empty logical vector.}

\item{.t}{\verb{[function / list]}

Vectorized test functions that indicate which elements of \code{.x}
to conditionally format. \code{.t} may be:
\itemize{
\item A named function, e.g. \code{is.na}
\item An anonymous function, e.g. \verb{\\(x) 0 <= x & x <= 1}
\item A purrr-style lambda, e.g. \code{~ nchar(.x) > 0}, \code{~ .h == 1}, \code{~ TRUE}
\item A list of functions or lambdas, e.g. \code{list(~ .x < mean(.x), is.finite)}
}

Each function in \code{.t} will receive \code{.x} as it's input and must return
a logical vector the same length as \code{.x} or of length 1 (in which case the
result will be recycled to the length of \code{.x}).

By default \code{.t} is the function \code{false()} which returns \code{FALSE} for any
input. You can modify this default by setting the \code{vlightr.default_test}
in \code{\link[=options]{options()}}.}

\item{.f}{\verb{[function / list]}

Vectorized character manipulation functions used to format \code{.x}. \code{.f} may be:
\itemize{
\item A named function, e.g. \link[cli:ansi-styles]{cli::style_bold}
\item An anonymous function, e.g. \verb{\\(words) gsub("hi", "hey", words)}
\item A purrr-style lambda, e.g. \code{~ paste0(.h, "!")}, \code{~ "fizz"}
\item A list of functions or lambdas, e.g. \code{list(~ cli::col_red(.x), toupper)}
}

Each formatter function in \code{.f} will receive a character vector (of variable length)
as it's only argument. A formatter must return a character vector the same
length as it's input or of length 1 (in which case the result is recycled to
the length of the input character).

ANSI string vectors (class \code{cli_ansi_string}) are also supported (see
\link[cli:ansi-styles]{cli::ansi-styles} for details).

By default \code{.f} is the function \verb{[cli::bg_br_yellow()]} which changes the
background color of it's input text to bright yellow. You can modify this
default by setting the \code{vlightr.default_formatter} in \code{\link[=options]{options()}}.}

\item{...}{\verb{[formula / vlightr_highlighter]}

For \code{highlighter_mult()} and \code{highlighter_case()}, a two sided formula with
a test on the left-hand-side and a formatter on the right-hand-side. This
argument replaces the \code{.t} and \code{.f} arguments of \code{highlight()}. The ith dot
\code{..i} is roughly equivalent to \code{.t[[i]] ~ .f[[i]]}.

The left-hand-side and right-hand-side of the formula may be:
\itemize{
\item A named function, e.g. \code{is.numeric}, \link[cli:ansi-styles]{cli::style_bold}
\item An anonymous function, e.g. \verb{\\(x) is.nan(x)}, \verb{\\(x) ifelse(x == "", "empty", x)}
\item A purrr-style lambda expression, e.g. \code{paste0(.h, "?")}, \code{"fizzbuzz"}
}

Additionally, the left-hand-side of the formula may be a scalar atomic object,
supplied by name e.g. \code{1}, \code{NaN}, \code{"Hello"}. This is a shorthand for
a test of equality. For example:
\itemize{
\item \code{10} corresponds to \code{.x == 10}, \code{"Word"} to \code{.x == "Word"}
\item \code{NaN} corresponds to \code{is.nan(.x)}
\item \code{NA} corresponds to \code{is.na(.x)}, \code{NA_int_} to \code{is.na(.x) & is.integer(.x)}
}

A one-sided formula (e.g. \code{~ tolower}) may also be supplied, in which case
every element of \code{.x} is formatted using the right-hand-side function
(e.g. \code{tolower}).

Finally, a highlighter, e.g. \code{highlighter(is.na, color("red"))}, may be
supplied instead of a formula. Every test (e.g. \code{.t}) and formatter
(e.g. \code{.f}) associated with the highlighter is inserted as a test
and formatter of the returned vector.

Examples of arguments to \code{...} include:
\itemize{
\item Color \code{NA} values red: \code{is.na ~ color("red")}
\item Add an exclamation mark: \code{toupper(.x) == .x ~ paste0(.x, "!")}
\item Label the number 1 as "Yes": \code{1 ~ "Yes"}
\item Color the background yellow by default: \code{~ cli::cli_bg_yellow(.x)}
}

In the case of \code{highlight_case()}, elements of \code{.x} can be conditionally
formatted at most once. Each element of \code{.x} is formatted using the formatter
corresponding to the first test which returns \code{TRUE} for that element.}
}
\value{
A vector of class \code{vlightr_highlight}. For \code{highlight_case()}, the a
vector of class \code{vlightr_highlight/vlightr_highlight_case}.
}
\description{
\code{highlight()} creates a vector with a conditional \code{\link[=format]{format()}}
and \code{\link[=print]{print()}} method. The function takes an input vector \code{.x}, a test
function \code{.t}, and a formatter function \code{.f}. When the result of
\code{highlight(.x, .t, .f)} is printed, elements of \code{.x} for which \code{.t} returns
\code{TRUE} are transformed by \code{.f} before they are printed.

\code{.t} and \code{.f} may be equal length lists of functions. Elements of \code{.x} for
which \code{.t[[i]]} returns true are transformed using \code{.f[[i]]}. Conditional
formats are applied to the highlighted vector in the order that they are
applied to \code{.t} and \code{.f}.

\code{highlight_mult()} and \code{highlight_case()} allow these pairs of functions to
be supplied as two-sided formulas \code{.t ~ .f} using \code{\link[dplyr:case_when]{dplyr::case_when()}}
style syntax.

\code{hl()} and \code{highlight()} are synonyms, as are \code{hl_mult()} and
\code{highlight_mult()}, \code{hl_case()} and \code{highlight_case()}.
}
\details{
The \code{highlighter_mult()} and \code{highlight_case()} formula syntax can conflict
with \code{dplyr::across()} in-lined formulas and other purrr-style-lambdas. In
particular, when the following is executed:

\if{html}{\out{<div class="sourceCode">}}\preformatted{dplyr::across(col, ~highlight_mult(.x, is.na(.x) ~ color("red")))
}\if{html}{\out{</div>}}

The formula \code{is.na(.x) ~ color("red")} will be replaced with
\code{is.na(y) ~ color("red")} by \code{dplyr::across()}. When the expression \code{is.na(col)}
is converted to a test function by \code{highlight_mult()}, the object \code{col} will
not exist in the environment of the test function, causing an error (or worse,
a difficult to diagnose bug) when the test function is called.

To avoid this behavior, vlightr allows the use of \code{.h} in it's
purrr-style-lambdas. Replacing \code{is.na(.x)} with \code{is.na(.h)}, as in the
following snippet, will work as expected:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ dplyr::across(y, ~highlight_mult(.x, is.na(.h) ~ color("red")))
}\if{html}{\out{</div>}}

All purrr-style-lambdas used by vlightr accept the symbols \code{.x}, \code{.h}, and \code{.}
as aliases for their first argument.
}
\examples{
# Emphasize NA values when `x_hl` is printed
x <- c(1, 0, NA, 1, 0)
x_hl <- highlight(x, is.na, ~paste("[", .x, "]"))
print(x)
print(x_hl)

# Track the maximum of `values`
values <- highlight(c(1, 5, 7, 3), ~ .x == max(.x), wrap("[", "]"))
print(values)
print(sort(values))
print(hl(-1) * values)

# Add labels to an indicator variable
indicator <- highlight_mult(
  c(0, 1, NA, 5),
  0 ~ label("No"),
  1 ~ label("Yes"),
  is.na ~ color("red"),
  !(.x \%in\% c(0, 1, NA)) ~ label("?")
)
print(indicator)

# Simplify using `dplyr::case_when()` style case matching.
# Elements are conditionally formatted using the first case
# where the left-hand-side returns `TRUE`.
indicator <- highlight_case(
  c(0, 1, NA, 5),
  0 ~ label("No"),
  1 ~ label("Yes"),
  is.na ~ color("red"),
  true ~ label("?") # `true()` is a function which returns `TRUE`
)
print(indicator)

# Make a `highlighter()` to add the formatting of `indicator`
# to other vectors.
indicator_highlighter <- as_highlighter(indicator)
indicator_highlighter(c(1, 0, 1, NA, -9))

# A highlighter can be supplied to `highlight_mult()` or
# `highlight_case()`. This is an easy way to append new
# options to an existing highlighter.
highlight_case(
  c(1, 2, 0, NA, -9),
  2 ~ label("Maybe"),
  indicator_highlighter
)

# Apply multiple formats to the same element
highlight_mult(
  1:6,
  .x \%\% 2 == 0 ~ wrap("<", ">"),
  .x >= 3 ~ wrap("[", "]")
)

# Apply a formatter to every element of `.x` by
# supplying a one-sided formula.
upper_letters <- highlight_mult(letters[1:10], ~ toupper)
print(upper_letters)

# Note that highlighting does not alter the underlying data
un_highlight(upper_letters)

# A one-sided formula supplied to `highlight_case()` will
# format all elements, even if they have already been formatted,
# over-riding the default matching behavior.
highlight_case(
  c(1, 1, 0),
  0 ~ "No",
  1 ~ "Yes",
  ~ toupper # `true ~ toupper` wouldn't format any elements
)

# By default no formatting is applied to a highlighted vector.
highlight(1:5) # No conditional formatting

# The default formatter `.f` colors the background of the
# formatted vector yellow. If you are reading this is in
# an environment which doesn't support ANSI coloring, you
# may not see the yellow background.
highlight(1:5, ~ .x > 3) # Yellow background

# Change the default test or formatter using `options()`
opts <- options() # Save previous options
options(vlightr.default_formatter = \(x) paste("{", x, "}"))
highlight(-2:2, ~ .x < 0)

options(vlightr.default_test = \(x) x > 0)
highlight(-2:2)
options(opts) # Reset previous options
}
\seealso{
\code{\link[=templight]{templight()}} for conditionally formatting elements of a vector \code{.x}
by location. Replaces the test \code{.t} with a vector of positions \code{.at}.

\code{\link[=is_highlightable]{is_highlightable()}} for testing whether an object can be highlighted.

\code{\link[=un_highlight]{un_highlight()}} for converting a vector \code{highlight(.x)} back to \code{.x}.

\code{\link[=tests]{tests()}}, \code{\link[=formatters]{formatters()}}, \code{\link[=highlight_functions]{highlight_functions()}} for setting and
getting the values of \code{.t} (i.e. tests) and \code{.f} (i.e. formatters) of a
highlighted vector.

\code{\link[=color]{color()}} and friends for generating formatter functions for use in \code{.f}.
}
